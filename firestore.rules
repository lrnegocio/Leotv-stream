/**
 * Core Philosophy: This ruleset implements a hybrid security model for the VideoVerse Player application.
 * It combines role-based access for administrators with a strict user-ownership model for personal data.
 * The primary goal is to allow administrators to manage all public content and user accounts, while users
 * can only read public content and manage their own private data. A critical security feature is a global
 * check that prevents users marked as 'isBlocked' from accessing any data.
 *
 * Data Structure:
 * - /users/{userId}: Private user data, owned by the user but manageable by admins.
 *   - /users/{userId}/sessions/{sessionId}: Subcollection for user session data, strictly owned by the user.
 * - /roles_admin/{adminId}: A lookup collection defining who is an administrator. Existence of a document
 *   with a user's UID as the ID grants admin privileges. This collection is not client-writable.
 * - /channels/{channelId}: Publicly readable content collection managed exclusively by admins. It contains
 *   nested subcollections for seasons and episodes.
 *
 * Key Security Decisions:
 * - Admin Privilege via Lookup: Admin status is determined by checking for the existence of a document in
 *   `/roles_admin/{uid}`. This is highly performant and secure, avoiding the need to place a role field
 *   on user documents. This collection is read-only from the client to prevent privilege escalation.
 * - Global Block Check: A helper function `isNotBlocked()` performs a `get` operation on the user's own
 *   profile before granting read access to any public content. This ensures that an admin's decision to
 *   block a user is enforced immediately across the entire application.
 * - User Data Privacy vs. Admin Management: Users have full control over their own data in `/users/{userId}`.
 *   However, administrators are granted `get`, `update`, and `delete` permissions on these documents to
 *   manage accounts (e.g., blocking users, extending trials), but are denied `list` access to protect user privacy.
 * - Public Content Model: All content under `/channels` is readable by any authenticated, non-blocked user.
 *   All write operations (create, update, delete) on this content are strictly limited to administrators.
 *
 * Denormalization for Authorization:
 * The `/roles_admin` collection is a prime example of denormalization. By creating a separate, simple
 * collection of admin UIDs, we avoid costly and complex lookups inside user documents. The `isBlocked`
 * flag on the user document is another example; its presence allows a single, fast check to gate access
 * to the entire app's content.
 *
 * Structural Segregation:
 * The ruleset clearly segregates private user data (`/users`) from public, admin-managed content (`/channels`).
 * This separation simplifies rules and makes public listing queries on content collections safe and efficient,
 * as there is no risk of exposing private data within those collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the document ID
     * in the `/roles_admin` collection, granting them admin privileges.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Returns true if the requesting user is the owner of the document.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the requesting user's profile document has `isBlocked` set to false.
     * This is a critical check for non-admins to access any content.
     */
    function isNotBlocked() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isBlocked == false;
    }

    /**
     * Returns true if the document being written to already exists.
     * Required for all update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Validates that an incoming 'create' request for a user document has a matching ID field.
     */
    function hasValidUserIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces immutability of the user ID field on update.
     */
    function userIdIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that an incoming 'create' request for a session document has a matching userId field.
     */
    function hasValidOwnerIdOnCreate(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability of the userId field on session updates.
     */
    function ownerIdIsImmutable() {
      return request.resource.data.userId == resource.data.id;
    }

    // ----------------------------------------------------------------------
    // User Profiles
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user can create their own profile document.
     * @allow (get, update, delete) The document owner or an admin can manage the profile.
     * @deny (list) No user can list all user profiles, protecting user privacy. Only admins can.
     * @deny (update) A user cannot change another user's profile.
     * @principle Enforces document ownership for users and provides admin override for management tasks.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
      allow update: if (isOwner(userId) && isExistingDoc() && userIdIsImmutable()) || (isAdmin() && isExistingDoc());
      allow delete: if (isOwner(userId) && isExistingDoc()) || (isAdmin() && isExistingDoc());
    }

    // ----------------------------------------------------------------------
    // User Sessions
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to a user's session data, used to prevent dual logins.
     * @path /users/{userId}/sessions/{sessionId}
     * @allow (create, get, list, update, delete) A user can fully manage their own session documents.
     * @deny (create, get, list, update, delete) A user cannot access another user's sessions. Admins are also denied access as this is user-managed state.
     * @principle Restricts access to a user's own data tree (Strict Ownership).
     */
    match /users/{userId}/sessions/{sessionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && hasValidOwnerIdOnCreate(userId);
      allow update: if isOwner(userId) && isExistingDoc() && ownerIdIsImmutable();
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    // ----------------------------------------------------------------------
    // Admin Roles
    // ----------------------------------------------------------------------

    /**
     * @description Manages the collection of administrator UIDs.
     * @path /roles_admin/{adminId}
     * @allow (get, list) An existing admin can read the list of other admins.
     * @deny (create, update, delete) This collection cannot be modified by any client. It must be managed server-side or via the Firebase Console to prevent privilege escalation.
     * @principle Secures role-defining data by making it client-immutable.
     */
    match /roles_admin/{adminId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // ----------------------------------------------------------------------
    // Public Content: Channels, Seasons, Episodes
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to the top-level Channels collection.
     * @path /channels/{channelId}
     * @allow (get, list) Any authenticated, non-blocked user can read channel data.
     * @allow (create, update, delete) Only admins can manage channels.
     * @deny (get, list) An unauthenticated or blocked user cannot read channel data.
     * @deny (create, update, delete) A regular user cannot modify channel data.
     * @principle Implements public read access for valid users with role-based write restrictions.
     */
    match /channels/{channelId} {
      allow get: if isSignedIn() && isNotBlocked();
      allow list: if isSignedIn() && isNotBlocked();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();

      /**
       * @description Controls access to the Seasons subcollection within a Channel.
       * @path /channels/{channelId}/seasons/{seasonId}
       * @allow (get, list) Any authenticated, non-blocked user can read season data.
       * @allow (create, update, delete) Only admins can manage seasons.
       * @principle Inherits the parent collection's model: public read, admin-only write.
       */
      match /seasons/{seasonId} {
        allow get: if isSignedIn() && isNotBlocked();
        allow list: if isSignedIn() && isNotBlocked();
        allow create: if isAdmin() && request.resource.data.channelId == channelId;
        allow update: if isAdmin() && isExistingDoc();
        allow delete: if isAdmin() && isExistingDoc();

        /**
         * @description Controls access to the Episodes subcollection within a Season.
         * @path /channels/{channelId}/seasons/{seasonId}/episodes/{episodeId}
         * @allow (get, list) Any authenticated, non-blocked user can read episode data.
         * @allow (create, update, delete) Only admins can manage episodes.
         * @principle Inherits the parent collection's model: public read, admin-only write.
         */
        match /episodes/{episodeId} {
          allow get: if isSignedIn() && isNotBlocked();
          allow list: if isSignedIn() && isNotBlocked();
          allow create: if isAdmin() && request.resource.data.channelId == channelId;
          allow update: if isAdmin() && isExistingDoc();
          allow delete: if isAdmin() && isExistingDoc();
        }
      }
    }
  }
}